---
title: Typy kt贸re ci偶ko zrozumie w Typescripcie
date: 02-12-2022
category: typescript
published: true
excerpt: Void, never, any i unknown. Ka偶dy z nich ma r贸偶ne zastosowanie. Natomiast czy zawsze wiadomo jaki typ powinnimy przypisa w r贸偶nych sytuacjach? Zazwyczaj tak, ale trzeba by wiadomym ich dziaania, r贸偶nic i istnienia.
---

Praca z Typescriptem jest bardzo przyjemna. Sam w sobie du偶o rzeczy uatwia i pozwala pisa kod, kt贸ry na pewno nie dopuci, aby doszo do niedozwolonych operacji. Wyciga do nas do i chtnie podpowiada nam jaki typ zwraca dana funkcja. Natomiast w naszym interesie jest, aby program by jak najbardziej przygotowany na potencjalne zagro偶enia. Dlatego tak wa偶ne jest przypisywanie poprawnego typu funkcjom i zmiennym, co jednak czasami nie jest to takie proste. Mimo to, pisz ten artyku 偶eby m贸c utrwali swoj wiedz, a przy okazji mo偶e Tobie te偶 pomo偶e to zrozumie lepiej niekt贸re typy w Typescripcie 

## Typ void

Typ `void` mo藕e przyj warto `null` lub `undefined`. Typescript wykorzystuje `void` jako typ zwracany przez funkcj. By mo偶e zapytasz: _"ale jak to funkcja kt贸ra nie ma sowa kluczowego `return` co zwraca?"_. Tak, sama funkcja kt贸ra z domysu nic nie powinna zwraca, zwraca wanie typ `void`. Jest to zwizane nie tyle co z Typescriptem, ale z samym Javascriptem, kt贸ry, w wypadku gdy nie ma 偶adnego sowa kluczowego `return`, zwraca wanie `undefined`.

```ts
const undefinedValue: void = undefined;
const nullValue: void = null;

const voidFunction = () => { // () => void 
  console.log('Ja nic nie zwracam ');
};
```

<Callout>Pr贸ba przypisania wartoci mo偶e si nie uda je偶eli flaga strictNullChecks jest wczona w tsconfig.json. Bardzo zachcam pozostawic te flag wczon, poniewa偶 chroni ona przed przypisaniem wartoci null i undefined, tam gdzie nie powinno to by mo偶liwe. Typescript lepiej te偶 wtedy podpowiada typy. Natomiast, na potrzeb tego przykadu, wyczyem t flag.</Callout>

## Typ never

Typ never jest typem, kt贸ry nie istnieje. Jedyne, co do niego mo偶emy przypisa, to samego siebie - czyli `never`. Tak wic, kiedy taki typ jest u偶yteczny, je偶eli tak naprawd nic nie mo偶e przyj? Zazwyczaj sami tego typu nie przypisujemy, chyba 偶e piszemy bibliotek i mamy w niej jaki typ warunkowy, o czym wspomn po藕niej. Najczciej jednak Typescript domyla si kiedy wystpi typ `never`. atwiej to bdzie przedstawi na przykadzie:

```ts
const functionWithNeverBlock = (value: number) => {
  if (typeof value === 'string') {
    const neverValue = value; // never
  }
  const numberValue = value; // number
}
```

Ten przykad mo偶e wydawa si troch absurdalny. Z g贸ry przecie偶 wiemy, 偶e nasz argument jest liczb. Natomiast, wanie na takie przykady jest przygotowany typ `never`. Mimo, 偶e to co robimy jest technicznie mo偶liwe, tak naprawd ta warto __jest niczym__, poniewa偶 kod w tej klamrze si po prostu nie wykona. Innym przykadem s funkcje, kt贸re nigdy nie skocz si wykonywa, albo takie, kt贸re nic nie robi poza zgaszaniem bdu.

```ts
const throwError = () => { // () => never
  throw new Error('Ja tu tylko zgaszam error ;/');
}

const inifiniteLoop = () => { // () => never
  while (true) {
    console.log('Nigdy nie m贸w nigdy ');
  }
}
```

Wszystkie jak dotd wymienione przykady otrzymay typ never tylko dlatego, 偶e sam Typescript tak si domyli. Std pytanie, kiedy mo偶e by sensowne u偶ycie tego typu? Bardzo czsto wykorzystuje si go przy __typach warunkowych__. By mo偶e nigdy si jeszcze z tym nie zetkne w Typescripcie, natomiast skadnia jest bardzo podobna do operatora tr贸jargumentowego w Javascripcie (ang. _ternary operator_).

```ts
type StringOrNumber<T> = T extends string ? string : number;
type StringType = StringOrNumber<''> // string
```

Powy偶szy przykad przedstawia typ warunkowy, kt贸ry sprawdza, czy nasz typ jest liczb czy stringiem. Bardziej sprawne oko zauwa偶y jednak, 偶e ten kod, tak naprawd ma bardzo du偶 wad. Bdzie dziaa wietnie, gdy jako typ, podamy mu stringa bd藕 liczb. Natomiast, co w wypadku, gdy podamy tam co innego? Dla przykadu, umiemy tam typ `boolean`.

```ts
type ShouldBeNeverType = StringOrNumber<boolean> // number
```

Jak wida, nasz typ przyj warto number, co jest nieprawidowe! Powinien przyj raczej nasz omawian warto `never`. Jak to zrobi?

```ts
type StringOrNumber<T> = T extends string ? string : T extends number ? number : never;
type ShouldBeNeverType = StringOrNumber<boolean> // never
```

Wanie w taki spos贸b. Ten operator warunkowy sprawdza, czy jego typ jest stringiem lub liczb. W przeciwnym wypadku, ustawia go na `never`.

## Typ any

Jest to najbardziej kojarzony typ, z wszystkich typ贸w, kt贸re opisuje w tym artykule. Do niego mo偶na przypisa ka偶d warto, kt贸ra jest poprawna w Javascripcie. Dlatego, trzeba na niego bardzo uwa偶a. Taka wolno nie jest dobra. `any` powinno si u偶ywa bardzo wiadomie i tylko w ostatecznych przypadkach. Bardzo czsto `any` wykorzystuje si w sytuacjach, gdy przepisuje si kod z Javascriptu do Typescriptu. Jednak z czasem rozwoju te typy zamienia si na bardziej specyficzne.

```ts
let anyValue: any = 7312;
anyValue = 'moge byc stringiem';
anyValue = { lub: 'moge byc obiektem' };
anyValue = ['nawet', 'tablica'];
```

To, co dzieje si wy偶ej, jest bardzo niebezpieczne. Gdy spr贸bujemy odwoa si do klucza obiektu, kt贸ry w tym momencie mo偶e by liczb, Typescript nie bdzie na nas krzycza i nie wska偶e nam bdu. U偶ywajc `any` niejako m贸wimy typescriptowi: _"Suchaj Typescript, nie b贸j si, daem `any` i ja to ogarn"_. Dlatego, ten typ trzeba omija. A co zrobi w wypadku, gdy naprawd nie wiemy, jaki typ bdzie miaa nasza warto?

## Typ unknown

Tak jak w `any`, do typu `unknown` mo偶na przypisa ka偶d warto. Natomiast, samego typu `unknown` nie mo偶na przypisywa do innych typ贸w. Brzmi to troch jak naukowy bekot. Przykad na pewno pomo偶e w zrozumieniu:

```ts
let unknownValue: unknown =  7312;
unknownValue = 'moge byc stringiem';
unknownValue = { lub: 'moge byc obiektem' };
unknownValue = ['nawet', 'tablica'];

const errorUnknown: number = unknownValue; // Error
const numberValue: number = typeof unknownValue === 'number' ? unknownValue : 0; // unknownValue || 0
```

Jak wida, do typu `unknown` przypisalimy takie same wartoci, jak wczeniej do typu `any`. Natomiast, gdy chcemy t zmienn przypisa do zmiennej o innym typie, to mamy bd. Musimy najpierw sprawdzi, czy zmienna jest poprawnego typu w trakcie dziaania programu. Dlatego, `unknown` wprowadza du偶y stopie bezpieczestwa i pozwola nam spa troszk lepiej.

Typ `unknown`, bardzo czsto jest wykorzystywany przy apaniu bd贸w w bloku `catch`. Nigdy nie mamy przecie偶 pewnoci, jakiego typu jest nasz error. By mo偶e jest stringiem, a mo偶e obiektem, a mo偶e jeszcze czym innym. Zamiast zgadywania, lepiej ju偶 wczeniej poprawnie otypowa sobie error i na jego zasadzie sprawdza mo偶liwe przypadki.

```ts
const thisThrowsError = async () => {
  try {
    await likelyToBreak();
  } catch (err: unknown) {
    if (err instanceof Error) {
      return console.error(err.message);
    }
    console.error('Oops, co poszo nie tak');
  }
}
```

## Podsumowanie

Nie ukrywam, 偶e informacji odnonie typ贸w troch jest. Om贸wilimy cztery typy: `void`, `never`, `any` i `unknown`. Ka偶dy z nich ma r贸偶ne zastosowanie, lecz czy zawsze wiadomo, jaki typ powinnimy przypisa w r贸偶nych sytuacjach? Zwykle tak, ale trzeba by wiadomym ich dziaania, r贸偶nic, zastosowania i istnienia.
