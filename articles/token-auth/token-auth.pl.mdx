---
title: Zapewne robisz to Åºle, czyli token na frontendzie ğŸ™…â€â™‚ï¸
date: 03-19-2022
category: javascript
published: true
excerpt: Przechoywanie tokena na frontendzie to jeden z najciÄ™Å¼szych tematÃ³w do zrozumienia dla poczÄ…tkujÄ…cych developerÃ³w. BezpieczeÅ„stwo aplikacji webowych jest bardzo waÅ¼ne, poniewaÅ¼ nie moÅ¼emy pozwoliÄ‡ komuÅ› na kradzieÅ¼ toÅ¼samoÅ›ci naszych uÅ¼ytkownikÃ³w ğŸ”
---

JeÅ¼eli od razu chcesz przejÅ›Ä‡ do meritum, to artykuÅ‚ zasadniczo omawia dwie metody:

1. <a href="#localStorage">LocalStorage</a>
2. <a href="#cookie">Cookie</a>
    - <a href="#httpOnly">httpOnly</a>
    - <a href="#secure">secure</a>
    - <a href="#sameSite">sameSite</a>

## WstÄ™p

Wiele aplikacji, ktÃ³re sÄ… w sieci, posiadajÄ… systemy rejestracji i logowania. Mimo, Å¼e taki scenariusz jest czÄ™sto uÅ¼ywany, to jego zakodowanie juÅ¼ nie jest takie proste. BezpieczeÅ„stwo aplikacji webowych jest bardzo waÅ¼ne, poniewaÅ¼ nie moÅ¼emy pozwoliÄ‡ komuÅ› na kradzieÅ¼ toÅ¼samoÅ›ci naszych uÅ¼ytkownikÃ³w. Trzeba to wszystko dobrze przemyÅ›lec ze strony backendowej, jak i frontendowej. Dlatego ten artykuÅ‚ omawia, jak powinniÅ›my obchodziÄ‡ siÄ™ z tokenem ğŸ¤­

## Scenariusz potwierdzania toÅ¼samoÅ›ci i przyznania dostÄ™pu

Logowanie na wielu stronach dziaÅ‚a podobnie. UÅ¼ytkownik wchodzÄ…c na serwisy takie jak Facebook, Youtube, czy Github, musi potwierdziÄ‡ swojÄ… toÅ¼samoÅ›Ä‡ - ten proces nazywa siÄ™ _uwierzytelnianiem_. NastÄ™pnie gdy uÅ¼ytkownik wykonuje zapytanie do chronionego zasobu, backend bÄ™dzie musi sprawdziÄ‡ czy moÅ¼e zwrÃ³ciÄ‡ Å¼Ä…dany zasÃ³b, czyli serwer dokonuje _autoryzacji_. Do tego potrzebny jest token, ktÃ³ry jest w pewnym sensie _dowodem osobistym_. Jak za pomocÄ… dowodu moÅ¼emy poznaÄ‡ kogoÅ› dane, tak samo za pomocÄ… tokena, moÅ¼emy sprawdziÄ‡ z kim mamy do czynienia. Jak jednak taki token jest wydawany?

<Image alt="Komunikacja aplikacji z serwerem. UÅ¼ytkownik rejestruje siÄ™ i loguje, a serwer zwraca mu token" src='/images/auth-flow.pl.jpg' layout="responsive" width="993" height="518" />

Proces logowania i rejestracji na powyÅ¼szym zdjÄ™ciu jest bardzo mocno uproszczony. Jednak jak moÅ¼esz zauwaÅ¼yÄ‡, przy 5 punkcie jest napisane - _uÅ¼ytkownik jest zalogowany a jego token..._. No wÅ‚aÅ›nie, co siÄ™ dzieje w tym momencie z tokenem? Musimy mieÄ‡ do niego dostÄ™p, jeÅ¼eli chcemy wykonywaÄ‡ zapytania do serwera i poÅ›wiadczyÄ‡, __Å¼e my to tak naprawdÄ™ my__, dlatego warto go zapisaÄ‡ w pamiÄ™ci przeglÄ…darki, Å¼eby uÅ¼ytkownik za kaÅ¼dym razem gdy wchodzi na stronÄ™, nie musiaÅ‚ ponownie potwierdzaÄ‡ toÅ¼samoÅ›ci.

<h2 id="localStorage">Przechowywanie tokena w localStorage</h2>

Jak juÅ¼ szczÄ™Å›liwie otrzymaliÅ›my token, to moÅ¼emy go zapisaÄ‡ w obiekcie __[localStorage](https://developer.mozilla.org/pl/docs/Web/API/Window/localStorage)__ przeglÄ…darki. W jaki sposÃ³b moÅ¼na to zrobiÄ‡?

```js
const signInUser = async (login, password) => {
  const signInURL = 'http://website.com/auth/signin'
  try {
    const response = await fetch(signInURL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ login, password }),
    });

    const { data } = await res.json();

    const { accessToken } = data;

    // Zapisz token w localStorage
    localStorage.setItem('accessToken', accessToken);
  } catch (err) {
    console.error('Ooops, coÅ› poszÅ‚o nie tak', err);
  }
};
```

Przechowywanie danych w localStorage jest jakimÅ› rozwiÄ…zaniem, ale trzeba pamiÄ™taÄ‡, Å¼e to zostaje zapisane w przeglÄ…darce uÅ¼ytkownika, a jak wiadomo __wszystko co znajduje siÄ™ na frontendzie moÅ¼e zostaÄ‡ przez kaÅ¼dego sprawdzone, nawet przez osobe trzeciÄ…__! Taki sposÃ³b jest podatny na ataki __[XSS](https://sekurak.pl/czym-jest-xss/)__ i ktoÅ› moÅ¼e _wstrzyknÄ…Ä‡_ wywoÅ‚anie skryptu na naszej stronie, ktÃ³ry nastÄ™pnie przechwyci token. PrzecieÅ¼ nie chcemy, Å¼eby trafiÅ‚ on w nieodpowiednie rÄ™ce.

<Image alt="Token zapisany w obiekcie localStorage" src='/images/token-xss.jpg' layout="responsive" width="1034" height="328" />

Jak widaÄ‡, jeÅ¼eli strona jest sÅ‚abo zabezpieczona, to moÅ¼na Å‚atwo pobraÄ‡ zawartoÅ›Ä‡ tokena. Dlatego _localStorage_ to bardzo niebezpieczne rozwiÄ…zanie i powinniÅ›my z niego zrezygnowaÄ‡. Na szczÄ™Å›cie mamy jeszcze inne moÅ¼liwoÅ›ci. Zobaczmy gdzie indziej moÅ¼na zapisaÄ‡ token.

<h2 id="cookie">Pzechowywanie tokena w ciasteczku</h2>

[Ciasteczko](https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie) (ang. _cookie_) rÃ³wnieÅ¼ pozwala przechowywaÄ‡ informacje na stronie, ale rÃ³Å¼ni siÄ™ od _localStorage_ tym, Å¼e moÅ¼e zostaÄ‡ ustawione zarÃ³wno przez serwer backendowy, lub przez aplikacje frontendowÄ…. JeÅ¼eli zdecydujemy siÄ™ na ustawienie ciasteczka na frontendzie, to bÄ™dzie tak samo jak wczeÅ›niej, Å¼e ktoÅ› moÅ¼e je wykraÅ›Ä‡. Dlatego powinniÅ›my zapisywaÄ‡ ciasteczko z tokenem poprzez serwer. ByÄ‡ moÅ¼e zapytasz - _Co to zmieni jak ustawiÄ™ ciasteczko przez backend? PrzecieÅ¼ to dalej bÄ™dzie zapisane w przeglÄ…darce_. Tak, to prawda, ale moÅ¼emy wtedy ustawiÄ‡ pewne flagi, ktÃ³re ograniczÄ… dostÄ™p do ciasteczka.

<h3 id="httpOnly">Flaga httpOnly</h3>

WÅ‚Ä…czona flaga _httpOnly_ zabezpiecza ciasteczko przed jego odczytaniem w aplikacji i jeÅ¼eli sprawdzimy zawartoÅ›Ä‡ _document.cookie_, to go tam nie bÄ™dzie. Wprowadza to bardzo duÅ¼y stopieÅ„ bezpieczeÅ„stwa. OdciÄ…Å¼amy teÅ¼ w ten sposÃ³b aplikacjÄ™ frontendowÄ… i nie musimy juÅ¼ martwiÄ‡ siÄ™ o umieszczeniu w nagÅ‚Ã³wku tokena, poniewaÅ¼ ciasteczko jest za kaÅ¼dym razem dodawane w zapytaniu.

W przykÅ‚adzie zaÅ‚Ã³Å¼my, Å¼e frontend i backend sÄ… pod tym samym adresem. Wykonujemy zapytanie na frontendzie za pomocÄ… funkcjÄ… _fetch_, ktÃ³ra jest wbudowana w przeglÄ…darce, jednak Å¼eby nasz token zostaÅ‚ doÅ‚Ä…czony musimy dodaÄ‡ jednÄ… rzecz.

```js
fetch(signInURL, {
  method: 'POST',
  credentials: 'include', // Trzeba to ustawiÄ‡!
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ login, password }),
});
```

Gdy ustawimy opcjÄ™ _credentials_ na _same-origin_, to ciasteczka bÄ™dÄ… doÅ‚Ä…czone do zapytania, ale tylko w obrÄ™bie tego samego _origin_. Czyli nasz token, ktÃ³ry znajduje siÄ™ w ciasteczku, bÄ™dzie przesyÅ‚any za kaÅ¼dym razem do serwera. Natomiast __[origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin)__ jest tym co widzimy w naszym pasku adresu przeglÄ…darki.

<Image alt="Token zapisany w obiekcie localStorage" src='/images/origin.pl.jpg' layout="responsive" width="973" height="253" />

Jako ciekawostkÄ™, moÅ¼na teÅ¼ ustawiÄ‡ opcjÄ™ _credentials_ na _include_, co umoÅ¼liwia przesyÅ‚anie ciasteczek miÄ™dzy rÃ³Åºnymi _origin_, ale to juÅ¼ nie jest bezpieczne poniewaÅ¼ inne serwery backendowe mogÅ‚yby odczytaÄ‡ nasze ciasteczko.

Teraz na backendzie musimy ustawiÄ‡ naszemu ciasteczku flagÄ™ _httpOnly_ na _true_. W tym przykÅ‚adzie serwer jest postawiony na [NodeJS](https://nodejs.org/) przy wsparciu [ExpressJS](https://expressjs.com/).

```js
const MAX_AGE_1_MONTH = 1000 * 3600 * 24 * 30;
res.cookie('access_token', accessToken, {
  httpOnly: true,
  maxAge: MAX_AGE_1_MONTH,
});
```

I juÅ¼ mamy bezpieczniejszÄ… autoryzacjÄ™ w naszej aplikacji. Ciasteczko _access\_token_ nie bÄ™dzie zwracane gdy podejrzymy zawartoÅ›Ä‡ _document.cookie_ na frontendzie.

<h3 id="secure">Flaga secure</h3>

Ciasteczko z flagÄ… _secure_, jak sama nazwa moÅ¼e sugerowaÄ‡, jest tylko wysyÅ‚ane do serwera gdy zapytanie jest szyfrowane protokoÅ‚em _HTTPS_. JeÅ¼eli nasza strona nie wykorzystuje tego protokoÅ‚u, to token nie zostanie przesÅ‚any. Chroni nas to przed przypadkowym wejÅ›ciem uÅ¼ytkownika na naszÄ… stronÄ™ przez protokÃ³Å‚ _HTTP_, ktÃ³ry by wysyÅ‚aÅ‚ _niebezpieczne_ zapytania.

```js
res.cookie('access_token', accessToken, {
  httpOnly: true,
  secure: true,
  maxAge: MAX_AGE_1_MONTH,
});
```

<h3 id="sameSite">Flaga sameSite</h3>

Flaga _sameSite_ wprowadza restrykcje z jakich domen mogÄ… wychodziÄ‡ autoryzowane zapytania. Zabezpiecza nas przed stronami, ktÃ³re wykonujÄ… zapytania do naszej strony wraz z podpiÄ™tym tokenem. Czyli nikt z nieupowaÅ¼nionej strony nie bÄ™dzie mÃ³gÅ‚ pobieraÄ‡ zasobÃ³w do ktÃ³rych nie ma dostÄ™pu, nawet gdy taki ktoÅ› ma podpiÄ™ty token w ciasteczku. Ten rodzaj ataku ma nazwÄ™ [CSRF](https://pl.wikipedia.org/wiki/Cross-site_request_forgery). 

Jako _sameSite_ moÅ¼na ustawiÄ‡ wartoÅ›Ä‡ _secure_, ale ta opcja jest zbyt restrykcyjna i blokuje linki, ktÃ³re sÄ… na innych stronach i kierujÄ… do naszego serwisu. Dlatego istnieje rÃ³wnieÅ¼ opcja _Lax_, ktÃ³ra jest zÅ‚otym Å›rodkiem, poniewaÅ¼ blokuje odbieranie ciasteczek z innych domen, ale umoÅ¼liwia robiÄ‡ przekierowania do naszej strony.

```js
res.cookie('access_token', accessToken, {
  httpOnly: true,
  secure: true,
  sameSite: 'lax',
  maxAge: MAX_AGE_1_MONTH,
});
```

JuÅ¼ teraz nasza aplikacja jest o wiele bezpieczniejsza niÅ¼ to co mieliÅ›my na poczÄ…tku. Teraz tylko rola serwera backendowego, Å¼eby sprawdzaÅ‚ przychodzÄ…ce do niego zapytania. Bardzo dobrze do tego nadaje siÄ™ _middleware_, poniwaÅ¼ weryfikuje czy token jest nieprawidÅ‚owy, lub czy go nie ma wcale, a jeÅ¼eli wszystko jest poprawne, to zwraca Å¼Ä…dany zasÃ³b.

```js
const authMiddleware = (req, res, next) => {
  const { access_token: accessToken } = req.cookies;

  if (!accessToken) {
    return res.status(401).json({ status: 401, message: 'Brak ciasteczka z tokenem' });
  }

  try {
    jwt.verify(accessToken, getEnv('ACCESS_TOKEN_SECRET'));
    next();
  } catch {
    return res.status(403).json({ status: 403, message: 'NieprawidÅ‚owy token' });
  }
};
```

## Podsumowanie

Jak widaÄ‡ jest duÅ¼o moÅ¼liwoÅ›ci jak obchodziÄ‡ siÄ™ z tokenem na frontendzie. NiektÃ³re rozwiÄ…zania sÄ… mniej bezpieczne (tak, patrzÄ™ na Ciebie _localStorage_ ğŸ‘€), a inne bardziej. Dlatego ten temat trzeba dobrze zrozumieÄ‡, Å¼eby nie naraÅ¼aÄ‡ naszych uÅ¼ytkownikÃ³w na niebezpieczeÅ„stwo.