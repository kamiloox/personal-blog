---
title: Typy kt贸re ci偶ko zrozumie w Typescripcie
date: 02-12-2022
category: typescript
published: true
excerpt: Void, never, any i unknown. Ka偶dy z nich ma r贸偶ne zastosowanie. Natomiast czy zawsze wiadomo jaki typ powinnimy przypisa w r贸偶nych sytuacjach? Zazwyczaj tak, ale trzeba by wiadomym ich dziaania, r贸偶nic i istnienia.
---

Praca z Typescriptem jest bardzo przyjemna. Sam w sobie du偶o rzeczy uatwia i programowanie w nim sprawia przyjemno. Pozwala pisa taki kod, kt贸ry na pewno nie przepuci 偶adnych niedozwolonych operacji. Wyciga do nas do i chtnie podpowiada nam nawet jaki jest typ zwracany przez funkcj. Natomiast to jest w naszej intencji, aby program by jak najbardziej przygotowany na potencjalne zagro偶enia. Dlatego tak wa偶ne jest przypisywanie poprawnego typu funkcjom i zmiennym. Sam Typescript daje du偶o mo偶liwoci, jednak czasami nie jest to takie proste. Sam przed pisaniem tego artykuu zmagaem si ze zrozumieniem niekt贸rych typ贸w. Artyku ten traktuje jako mo偶liwo utrwalenia wiedzy, a przy okazji mo偶e Tobie te偶 pomog to zrozumie.

## Typ void

Typ `void` mo藕e mo偶e przyj warto `null` lub `undefined`. Typescript wykorzystuje `void` jako typ zwracany przez funkcj. By mo偶e zapytasz: _"ale jak to funkcja kt贸ra nie ma sowa kluczowego `return` co zwraca?"_. Tak, sama funkcja kt贸ra z domysu nic nie zwraca, to zwraca wanie typ `void`. Jest to zwizane nie tyle co z Typescriptem, ale z samym Javascriptem, kt贸ry gdy nie ma 偶adnego `return` zwraca wanie `undefined`.

```ts
const undefinedValue: void = null;
const nullValue: void = null;

const voidFunction = () => { // () => void 
  console.log('Ja nic nie zwracam ');
};
```

<Callout>Pr贸ba przypisania wartoci mo偶e si nie uda je偶eli flaga strictNullChecks jest wczona w tsconfig.json. Bardzo zachcam pozostawic te flag wczon, poniewa偶 chroni ona przed przypisaniem wartoci null i undefined, tam gdzie nie powinno to by mo偶liwe. Typescript lepiej te偶 wtedy podpowiada typy. Natomiast dla demonstracji tego przykadu wyczyem t flag.</Callout>

## Typ never

Typ never jest typem kt贸ry nie istnieje. Jedyne co do niego mo偶emy przypisa to tylko samego siebie - czyli `never`. Tak wic kiedy taki typ jest u偶yteczny, je偶eli on tak naprawd nic nie mo偶e przyj? Zazwyczaj sami tego typu nie przypisujemy, chyba 偶e piszemy bibliotek i mamy w niej jaki typ warunkowy, ale o tym po藕niej. Najczciej jednak Typescript domyla si kiedy bdzie typ `never`. atwiej to bdzie przedstawi na przykadzie.

```ts
const functionWithNeverBlock = (value: number) => {
  if (typeof value === 'string') {
    const neverValue = value; // never
  }
  const numberValue = value; // number
}
```

Ten przykad mo偶e wydawa si troch absurdalny. Z g贸ry przecie偶 wiemy, 偶e nasz argument jest liczb. Natomiast wanie na takie przykady jest przygotowany `never`. Mimo, 偶e to co robimy jest technicznie mo偶liwe, to tak naprawd ta warto __jest niczym__, bo ten kod si po prostu w tej klamrze nie wykona. Innym przykadem s funkcje kt贸re nigdy nie skocz si wykonywa, albo takie kt贸re nic nie robi poza zgaszaniem bdu.

```ts
const throwError = () => { // () => never
  throw new Error('Ja tu tylko zgaszam error ;/');
}

const inifiniteLoop = () => { // () => never
  while (true) {
    console.log('Nigdy nie m贸w nigdy ');
  }
}
```

Wszystkie jak dotd wymienione przykady otrzymay typ never tylko, 偶e sam Typescript tak si domyli. Natomiast kiedy mo偶e by sensowne u偶ycie tego typu przez nas? Bardzo czsto wykorzystuje si go przy __typach warunkowych__. By mo偶e nigdy si jeszcze z tym nie zetkne w Typescripcie, natomiast skadnia jest bardzo podobna do operatora tr贸jargumentowego w Javascripcie (ang. _ternary operator_).

```ts
type StringOrNumber<T> = T extends string ? string : number;
type StringType = StringOrNumber<''> // string
```

Powy偶szy przykad zawiera typ warunkowy, kt贸ry sprawdza czy nasz typ jest liczb czy stringiem. Bardziej sprawne oko zauwa偶y jednak, 偶e ten kod tak naprawd ma bardzo du偶 wad. On bdzie dziaa wietnie, gdy jako typ podamy mu stringa bd藕 liczb. Natomiast co gdy podamy tam co innego? Dla przykadu gdy umiecimy tam `boolean`.

```ts
type ShouldBeNeverType = StringOrNumber<boolean> // number
```

Jak wida nasz typ przyj warto number co jest nieprawidowe! Powinien przyj raczej nasz omawian warto `never`. Jak to zrobi?

```ts
type StringOrNumber<T> = T extends string ? string : T extends number ? number : never;
type ShouldBeNeverType = StringOrNumber<boolean> // never
```

Wanie w taki spos贸b. Ten operator warunkowy sprawdza czy jego typ jest stringiem lub liczb. W przeciwnym przypadku ustawia go na `never`.

## Typ any

Jest to najbardziej kojarzony typ z wszystkich typ贸w, kt贸re opisuje w tym artykule. Do niego mo偶na przypisa ka偶d warto, kt贸ra jest poprawna w Javascripcie. Dlatego trzeba bardzo uwa偶a. Taka wolno, nie jest dobra. Powinno si `any` u偶ywa bardzo wiadomie i tylko w rzadkich przypadkach. Bardzo czsto `any` wykorzystuje si w sytuacjach gdy przepisuje si kod z Javascriptu do Typescriptu. Jednak z czasem rozwoju te typy zamienia si na bardziej specyficzne.

```ts
let anyValue: any = 7312;
anyValue = 'moge byc stringiem';
anyValue = { lub: 'moge byc obiektem' };
anyValue = ['nawet', 'tablica'];
```

To co wy偶ej si dzieje jest bardzo niebezpieczne. Gdy spr贸bujemy odwoa si do klucza obiektu, kt贸ry w tym momencie mo偶e by liczb, Typescript nie bdzie na nas krzycza, i nie wska偶e nam bdu. U偶ywajc `any` niejako m贸wimy typescriptowi: _"Suchaj Typescript, nie b贸j si daem `any` i ja to ogarn"_. Dlatego ten typ trzeba omija. A co zrobi w wypadku gdy naprawd nie wiemy jaki typ bdzie miaa nasza warto?

## Typ unknown

Tak jak w `any` do typu `unknown` mo偶na przypisa ka偶d warto. Natomiast samego typu `unknown` nie mo偶na przypisywa do innych typ贸w. Troch brzmi to jak naukowy bekot. Przykad na pewno tutaj pomo偶e w zrozumieniu.

```ts
let unknownValue: unknown =  7312;
unknownValue = 'moge byc stringiem';
unknownValue = { lub: 'moge byc obiektem' };
unknownValue = ['nawet', 'tablica'];

const errorUnknown: number = unknownValue; // Error
const numberValue: number = typeof unknownValue === 'number' ? unknownValue : 0; // unknownValue || 0
```

Jak wida do typu `unknown` przypisalimy takie same wartoci jak wczeniej co do typu `any`. Natomiast gdy chcemy t zmienn przypisa do zmiennej o innym typie to mamy bd. Musimy najpierw sprawdzi czy zmienna jest poprawnego typu w trakcie dziaania programu. Dlatego `unknown` wprowadza du偶y stopie bezpieczestwa i pozwola nam spa troszk lepiej.

Typ `unknown` bardzo czsto jest wykorzystywany przy apaniu bd贸w w bloku `catch`. Nigdy nie mamy przecie偶 pewnoci jakiego typu jest nasz error. By mo偶e jest stringiem, a mo偶e obiektem, a mo偶e jeszcze czym innym. Zamiast zgadywania lepiej ju偶 wczeniej poprawnie otypowa sobie error, i na jego zasadzie sprawdza mo偶liwe przypadki.

```ts
const thisThrowsError = async () => {
  try {
    await likelyToBreak();
  } catch (err: unknown) {
    if (err instanceof Error) {
      return console.error(err.message);
    }
    console.error('Oops, co poszo nie tak');
  }
}
```

## Podsumowanie

Nie ukrywam, 偶e tej wiedzy odnonie typ贸w troch jest. Om贸wilimy waciwie cztery: `void`, `never`, `any` i `unknown`. Ka偶dy z nich ma r贸偶ne zastosowanie. Natomiast czy zawsze wiadomo jaki typ powinnimy przypisa w r贸偶nych sytuacjach? Zazwyczaj tak, ale trzeba by wiadomym ich dziaania, r贸偶nic i istnienia.